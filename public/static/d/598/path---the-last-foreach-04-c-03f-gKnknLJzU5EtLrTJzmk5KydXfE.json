{"data":{"site":{"siteMetadata":{"title":"GatsbyJS Hello","author":"diescake"}},"markdownRemark":{"id":"2979f979-8014-5910-948a-3f133bbc05f8","excerpt":"この記事は JavaScript2 Advent Calendar 2018 の 1 日目の記事です。こんばんは。@diescake です。今年は、JavaScript…","html":"<p>この記事は <a href=\"https://qiita.com/advent-calendar/2018/javascript_02\">JavaScript2 Advent Calendar 2018</a> の 1 日目の記事です。</p>\n<p>こんばんは。@diescake です。</p>\n<p>今年は、JavaScript 経験の浅い新人さんや外注さんをリードする立場として、\nとにかく幅広いメンバーのコードレビューをする機会に恵まれたのですが、\n事ある毎に <code class=\"language-text\">Array.prototype.forEach</code> を利用する人が多かったため、初心者向けに要点を整理してみました。</p>\n<p>以下 ES2015 以降のバージョンをサポートするブラウザ、あるいは polyfill を利用していることを前提としています。</p>\n<h1>結論</h1>\n<p>配列に対して何らかの操作を行う際は、\n<code class=\"language-text\">filter</code>, <code class=\"language-text\">find</code>, <code class=\"language-text\">map</code>, <code class=\"language-text\">reduce</code> などのメソッドを利用できないか検討し、\nいずれのメソッドでも実現ができない場合の最終手段として <code class=\"language-text\">forEach</code> を選択しましょう。</p>\n<p>下記に、いくつかのサンプルコードを例に説明していきます。</p>\n<h1>forEach ➔ filter</h1>\n<p>まず、最初に <code class=\"language-text\">Array.prototype.filter</code> の例です。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">const pomeranians = []\n\ndogs.forEach(dog =&gt; {\n  if (dog.type === &#39;pomeranian&#39;) {\n    pomeranians.push(dog)\n  }\n})</code></pre></div>\n<p>このコードでは、配列 <code class=\"language-text\">dogs</code> のうち特定の条件に合致した要素を全て抜き出しています。</p>\n<p>勿論この実装でも正常に動作しますが、\nこのケースでは下記のように <code class=\"language-text\">filter</code> を利用することでより簡潔に記述できます。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:filter\"><pre class=\"language-js:filter\"><code class=\"language-js:filter\">const pomeranians = dogs.filter(dog =&gt; {\n  return dog.type === &#39;pomeranian&#39;\n})</code></pre></div>\n<p>さらに、実際には arrow function の shorthand を利用することでさらにコンパクトになります。\n(これ以降の例では shorthand によるコードのみを紹介します)</p>\n<div class=\"gatsby-highlight\" data-language=\"js:filter(shorthanded)\"><pre class=\"language-js:filter(shorthanded)\"><code class=\"language-js:filter(shorthanded)\">const pomeranians = dogs.filter(dog =&gt; dog.type === &#39;pomeranian&#39;)</code></pre></div>\n<p>さて、<code class=\"language-text\">forEach</code> から <code class=\"language-text\">filter</code> に書き換えたことによって、コードが短く簡潔になったことはわかると思いますが、\nそれよりも重要なメリットは、</p>\n<p>配列のループ処理に <code class=\"language-text\">filter</code> が利用されていることで、このコードを見た人に、\n<strong>このループが dogs の subset を抽出している、という意図が瞬間的に伝わる</strong> ということです。</p>\n<p><code class=\"language-text\">forEach</code> は配列をループするという目的と意味しか持たないため、\n何のためにループを行っているのか把握するためには、実装の詳細を追う必要がありますが、\n<code class=\"language-text\">filter</code> が利用されている場合、コードの詳細を読まずとも、処理全体として特定条件の要素を抜き出す処理を行っているだろうことが伝わります。</p>\n<p>コードリーディングにおいて、ループの処理を読み解くのは脳に対する負荷は高くなりがちですが、\n前もって処理全体の目的が分かれば、詳細を理解するにあたって大きくコストを削減できます。</p>\n<p>ここでは <code class=\"language-text\">filter</code> の例で説明しましたが、それ以外の <code class=\"language-text\">find</code>, <code class=\"language-text\">map</code>, <code class=\"language-text\">reduce</code> についても同様のメリットがあり、\n適切なメソッドを選択することで、リーダビリティに優れたコードとなるため重要です。</p>\n<h1>forEach ➔ find</h1>\n<p>続いて <code class=\"language-text\">Array.prototype.find</code> です。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">let myDog\n\ndogs.forEach(dog =&gt; {\n  if (dog.name === &#39;ポメラニアス3世&#39;) {\n    myDog = dog\n  }\n})</code></pre></div>\n<p>このコードでは、配列 <code class=\"language-text\">dogs</code> から、特定の要素を抜き出しています。</p>\n<p>また、<code class=\"language-text\">forEach</code> ではループの <code class=\"language-text\">break</code> が実現できない点が気にかかり、\nもっと素朴に <code class=\"language-text\">for</code> 文で記述する人も見かけましたが、\nいずれもあまり良いコードとはいえません。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:for\"><pre class=\"language-js:for\"><code class=\"language-js:for\">let myDog\n\nfor (let i = 0; i &lt; dogs.length; i++) {\n  if (dog.name === &#39;ポメラニアス3世&#39;) {\n    myDog = dog\n    break\n  }\n}</code></pre></div>\n<p>このケースでは下記のように <code class=\"language-text\">find</code> を利用することでより目的を明確にし、簡潔に記述できます。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:find\"><pre class=\"language-js:find\"><code class=\"language-js:find\">const myDog = dogs.find(dog =&gt; dog.name === &#39;ポメラニアス3世&#39;)</code></pre></div>\n<p>ちなみに、<code class=\"language-text\">filter</code> を使うと以下のように書けます。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:filter\"><pre class=\"language-js:filter\"><code class=\"language-js:filter\">const myDog = dogs.filter(dog =&gt; dog.name === &#39;ポメラニアス3世&#39;)[0]</code></pre></div>\n<p>コードの実装量からすると、どちらも大した差はないように見えますが、\n先程説明したように、<code class=\"language-text\">find</code> を使うことで、配列から特定の要素 1 つを検索して抜き出すという意図が明確になるため、\n<code class=\"language-text\">filter</code> より <code class=\"language-text\">find</code> を利用するのが良いでしょう。</p>\n<p>特にこのケースで <code class=\"language-text\">filter</code> の戻り値を配列のまま変数で受けると、\n<code class=\"language-text\">myDogs[0]</code> のように index を指定して先頭の要素のみを参照することになりますが、\nこの場合、配列の先頭は何を意味するのか？、先頭以外の要素はなぜ参照しないのか？といった労力を読み手に課すことになるため、避けたほうが良いでしょう。</p>\n<h1>forEach ➔ map</h1>\n<p>3 番目、<code class=\"language-text\">Array.prototype.map</code> です。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">const dogNames = []\n\ndogs.forEach(dog =&gt; {\n  dogNames.push(dog.name)\n})</code></pre></div>\n<p>このコードは、配列 <code class=\"language-text\">dogs</code> の各要素を参照して、別の配列を作り出す例です。\n別の構成の配列を作り出すようなケースでは <code class=\"language-text\">map</code> を使うときれいにかけます。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:map\"><pre class=\"language-js:map\"><code class=\"language-js:map\">const dogNames = dogs.map(dog =&gt; dog.name)</code></pre></div>\n<p>この例ではあまりにシンプル過ぎてメリットが伝わらないかもしれませんが、\nReact で JSX を扱う場合は、必ず利用するといっても良いくらい活躍の場は多いです。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx:map\"><pre class=\"language-jsx:map\"><code class=\"language-jsx:map\">render() {\n  return (\n    &lt;ul&gt;\n      {this.props.dogs.map(dog =&gt; &lt;li&gt;{`${dog.name}: ${dog.description}`}&lt;/li&gt;)}\n    &lt;/ul&gt;\n  );\n};</code></pre></div>\n<p>また、下記のように、特定の要素のみを加工して配列に作るというケースはあると思いますが、\n<code class=\"language-text\">map</code> だけでは要素の取捨選択を行うことはできないため <code class=\"language-text\">filter</code> と組み合わせて実現することになります。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">const pomeranians = []\n\ndogs.forEach(dog =&gt; {\n  if (dog.type === &#39;pomeranian&#39;) {\n    pomeranians.push({\n      id: uuid(),\n      name: dog.name,\n    })\n  }\n})</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js:filter->map\"><pre class=\"language-js:filter->map\"><code class=\"language-js:filter->map\">const animals = dogs.filter(dog =&gt; dog.type === &#39;pomeranian&#39;)\n  .map(dog =&gt; ({\n    id: uuid(),\n    name: dog.name,\n  });</code></pre></div>\n<p><code class=\"language-text\">map</code> で処理する前に <code class=\"language-text\">filter</code> で条件にあった配列を抜き出しています。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:map->filter\"><pre class=\"language-js:map->filter\"><code class=\"language-js:map->filter\">const animals = dogs.map(dog =&gt; {\n  if (dog.type !== &#39;pomeranian&#39;) {\n    return null;\n  }\n  return {\n    id: uuid(),\n    name: dog.name,\n  };\n}.filter(v =&gt; v);</code></pre></div>\n<p>上記は逆に <code class=\"language-text\">map</code> で処理してから <code class=\"language-text\">filter</code> する例です。</p>\n<p>この例では前者の方が簡潔ですが <code class=\"language-text\">filter</code> する条件が複雑化した場合、\n<code class=\"language-text\">map</code> 関数中で適宜 early return した <code class=\"language-text\">null</code> を後からまとめて <code class=\"language-text\">filter</code> で弾く方が見通し良く記述できる場合があります。</p>\n<p>ちなみに、配列に対する <code class=\"language-text\">.filter(v =&gt; v)</code> という記述で、\n配列中の falsy な値を全て除くことができるというのは覚えておいて損はないと思います。</p>\n<h1>forEach ➔ reduce</h1>\n<p>最後に <code class=\"language-text\">Array.prototype.reduce</code> です。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">let total = 0\n\ndogs.forEach(dog =&gt; {\n  total += dog.price\n})</code></pre></div>\n<p>このコードは、配列 <code class=\"language-text\">dogs</code> の各要素を参照して、合計値を計算している例です。</p>\n<p>実は前 3 つと比較すると <code class=\"language-text\">reduce</code> を使った方が良いです！！とコメントしたケースは少なかったのですが、\nこういった配列の合計値を求める処理や、文字列連結を行う際に、\n変数宣言を <code class=\"language-text\">let</code> から <code class=\"language-text\">const</code> に書き換えることができるという点が便利ですね。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:reduce\"><pre class=\"language-js:reduce\"><code class=\"language-js:reduce\">const total = dogs.reduce((acc, dog) =&gt; acc + dog.price, 0)</code></pre></div>\n<p>また、次の項目で紹介しますが、\n内部状態を持つインスタンスを生成し、ループ中でインスタンスメソッドを呼び出し、\n最終的に内部状態が変更されたインスタンスを戻り値として返すような処理がワンライナーで書くことができるので、ビシッと嵌まるときがあります。</p>\n<p>ただ、<code class=\"language-text\">reduce</code> も <code class=\"language-text\">forEach</code> 程ではないですが、比較的万能なので、\n乱用すると意図がよくわからないコードになりがちな気はします。</p>\n<h1>forEach が妥当なケース</h1>\n<p>さて、逆に <code class=\"language-text\">Array.prototype.forEach</code> での記述が妥当だと感じた例です。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">dogs.forEach(dog =&gt; {\n  console.log(dog.name)\n})</code></pre></div>\n<p>外部のスコープに対して直接関与しない場合は、<code class=\"language-text\">forEach</code> での記述は妥当な気がします。\n(すぐに思い浮かびませんが、例外は何かあるかも…)</p>\n<p>また、上記例に近くはありますが <code class=\"language-text\">fetch</code> や通知など、非同期処理を呼び出す場合は、\n<code class=\"language-text\">forEach</code> でループごとに <code class=\"language-text\">await</code> することができないことと、実際には <code class=\"language-text\">Promise.all</code> を利用して並行処理できるケースが多いと思うので、\nこの場合は Promise の配列を返すために <code class=\"language-text\">map</code> を利用することになると思います。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:map\"><pre class=\"language-js:map\"><code class=\"language-js:map\">await Promise.all(dogs.map(async dog =&gt; await dog.eat(&#39;ペディグリーチャム&#39;));</code></pre></div>\n<p>次に、ある内部状態を持つインスタンスに対して、インスタンスメソッドで操作する例です。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:foreach\"><pre class=\"language-js:foreach\"><code class=\"language-js:foreach\">const pomeranian = new Pomeranian()\n\nfoods.forEach(food =&gt; {\n  if (food.type === &#39;beef&#39;) {\n    pomeranian.add(food)\n  }\n})</code></pre></div>\n<p>ちなみに、<code class=\"language-text\">reduce</code> で記述すると下記のように書けます。</p>\n<div class=\"gatsby-highlight\" data-language=\"js:reduce\"><pre class=\"language-js:reduce\"><code class=\"language-js:reduce\">const pomeranian = foods.reduce((pomeranian, food) =&gt; {\n  if (food.type === &#39;beef&#39;) {\n    pomeranian.add(food)\n  }\n  return pomeranian\n}, new Pomeranian())</code></pre></div>\n<p>ただこれは <code class=\"language-text\">forEach</code> に比べて簡潔になったかというと微妙で、\n関数の戻り値としてインスタンスを受けたいケースでない場合は、<code class=\"language-text\">forEach</code> で記述されていても、\n好みの範疇で特に問題はないかなと感じます。</p>\n<h1>まとめ</h1>\n<p>というわけで、ちょっと微妙なサンプルもあったと思いますが、<code class=\"language-text\">forEach</code> を書き換える例を紹介しつつ、\nなぜ、書き換えた方が良いか？という話をしてみました。</p>\n<p><code class=\"language-text\">forEach</code> を利用すると何でもできてしまうが故に、\n1 つのループ中で、複数意図の処理を詰め込み、\n<code class=\"language-text\">if</code> 文を乱立させたり、<code class=\"language-text\">for</code> をネストさせて…、と、スパゲッティ化した PR をいくつも見ました。</p>\n<p>元々 <code class=\"language-text\">forEach</code> は戻り値を持たないので、意味のある処理を実現しようとすると外部スコープに対する操作が前提となり、\nともすると、あれもこれもと、やり放題になってしまうのかなと感じています。</p>\n<p>また、実際にウェブアプリを実装する際には、\nlodash, immutable.js, Rambda などの colletion を操作するライブラリを利用するのは有効ですが、\nbundle したファイルサイズにも影響してきますので、無理がない場合は vanilla で書くことは良いユーザ体験に繋がると思います。</p>\n<p>最後に、ほぼパフォーマンスについては言及しませんでしたが、\n最も素朴に <code class=\"language-text\">for</code> 文で記述する方が恐らく速く(要出展)、リーダビリティとトレードオフになるとは思います。</p>\n<p>ただし、<code class=\"language-text\">for</code> が速いとはいえ、この書き換えによって、パフォーマンスに大きく差異がでるケースは稀だと思っていて、\nチューニングフェーズで、実測して明らかにボトルネックであることが判明してから、書き換えを検討するという方向性が良いと思います。</p>\n<p>(この書換えによって、パフォーマンスに大きく差異がでる程のループ処理を JavaScript 上で行う必要がある時点でサービス全体の設計に問題がある気が…)</p>\n<p>さて、明日は @ttokutake さんです。 （╹◡╹）</p>","frontmatter":{"title":"JavaScript で forEach を使うのは最終手段","date":"December 07, 2018","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/the-last-foreach/","previous":{"fields":{"slug":"/hi-folks/"},"frontmatter":{"title":"New Beginnings"}},"next":{"fields":{"slug":"/read-pair-programming/"},"frontmatter":{"title":"「はじめてのペアプロ / モブプロ」を読んだメモ"}}}}